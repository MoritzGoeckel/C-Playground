//String to Int
int num = atoi(char[] str)

//Console out
puts("...")

//Formatted multitype output
printf("%s %i %p", somechar[], someint, somepointer)

//Read int
int decks
scanf("%i", &decks) //have to use the adress
//%f for floating point number

//Read string
char s[20];
scanf("%19s", s) //up to 19 chars into s

//Read string fgets
fgets(s, sizeof(s), stdin); //stdin == keyboard

//Main
int main(){ return 0; }

//libs
#include <stdio.h>
#include <stdlib.h>

//Adress
&var

//Pointer
int* p = &var;

//Dereference
int num = *p;
*p = 10;

//Create a string
char s[] = "Hallo Welt"

//String pointers are immutable
char* s = "Hallo Welt"
s[5] = 'A'; //-> ERROR

//Sizeof
sizeof(int) -> 4
sizeof("1234") -> 4 + 1 -> 5

//Arrays are converted to pointers to first element when passed to a function
//Size of array is not retrievable after conversion to pointer. 
//This loss of information is called "decay"
char s[] = "Hallo Welt"
sizeof(s) -> 11 //Size of the array
size(s); -> 8 //Size of the pointer s
void size(char s[]){
	return sizeof(s) 
}

//arrays are implicitly converted to pointers to the first element
int c[] = {1,2,3};
int* pi = c; //Ok
*pi // -> 1

//Init array
int i[] = {1, 2, 3, 4};

//Accessing array element
i[0]
*(i + 0)

//Accessing array from element 6
i + 6

//A riddle
int i[] = {1, 2, 3};
i[2] == *(i + 2) == *(2 + i) == 2[i]


//Const!
const int i = 0;

//String functions
#include <string.h>
strlen //length
strcat //concatinate two strings
strcpy //copy string from one to another
strstr //find location of one string in another
strcmp //compare two strings
strchr //find location of char in string

//Redirecting input with < and the output with >
first < data.txt > out.txt

//Redirecting stderr
first < data.txt 2> errors.txt

//Piping data from one software to the other
some | thing < input.txt > output.txt

//Send to stdout and stderr
fprintf(stdout, "I like turtles")
fprintf(stderr, "I like turtles %i", someint)

//File
FILE* in = fopen("input.txt", "r");
FILE* out = fopen("output.txt", "w");

fprintf(out, "Yo");
fscanf(in, "%79", chars)

fclose(in);

//Commandline parameters
int main(int argcount, char *argv[]){ return 0; }
//First parameter is name of software

//Read option flags
#include <unistd.h>
getopt(argc, argv, "optionstring")

//Casting like in Java
float x = (float) y / z;

//Unsigned and long variables
unsigned long x; //Double the size of a long
long long x; //Really big number
long double x; //Really percise number

//Get limits
#include <limits.h> //For int ant chars etc
#include <float.h> //For float
INT_MAX, INT_MIN
FLT_MAX, FLT_MIN

//Declare functions via their signature first to avoid problems with the order of definition
float returnsomeFloat(int x);

//This can be extracted into a h header file
//The import of this file looks like this
#include "filename.h"

//Share variables: Define them in an header file, mark them with extern
extern int a = 0;

//Compile and link multiple files
//Create header, include header in all c files -> can use function
g++ somename.c someother.c -o out

//Compile all files to object code (auto skip existing)
gcc -c *.c

//Link files after object code is generated
gcc *.o -o out

//Make compile
target.o: dependency1.c dependency2.c dependency3.h
	gcc -c target.c
	
//Make link
target: dependency1.o dependency2.o
	gcc dependency1.o dependency2.o -o target
	
//Create makefiles with autoconf

//Strunct
struct fish {
	int size;
	const char* name; 
}

//Instanciate
struct fish mark = {10, "Mark"};

//Access
mark.size = 20;

//typedef to alias types
typedef int zahl;
zahl a = 10;

//Possible to skip struct name with typedef
typedef struct {
	int size;
	const char* name; 
} fish;

//fish* f = &{10, "Mark"};
(*f).size //10
*f.size // == *(f.size) ERROR
f->size //10

//Init struct
fish f = {.size = 10};

//Union is a struct that only holds one data
typedef union{
	int count;
	float liters;
} quantity;
//You can only set one value, the size is equal to the bigger possible types size

//enums
enum colors {RED, GREEN, BLUE};
enum colors favoriteColor = BLUE;
typedef enum {RED, GREEN, BLUE} colors;

//Bitfields; How many bits shoulds be reserved?
unsigned int onebit:1; //Only uses one bit -> 0/1